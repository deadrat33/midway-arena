<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MIDWAY – Shared Swarm Arena</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }
    #ui {
      position: absolute;
      top: 12px;
      left: 12px;
      width: 260px;
      background: rgba(0,0,0,0.8);
      border-radius: 8px;
      padding: 10px 12px;
      box-shadow: 0 0 12px rgba(0,0,0,0.7);
      font-size: 13px;
      z-index: 10;
    }
    #title {
      letter-spacing: 0.18em;
      font-size: 16px;
      margin-bottom: 6px;
    }
    #controls button {
      margin: 4px 4px 4px 0;
      padding: 4px 10px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
      color: #eee;
      cursor: pointer;
      font-size: 12px;
    }
    #controls button:hover {
      background: #222;
    }
    #stats {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 6px;
      font-size: 12px;
    }
    #connectionStatus {
      margin-top: 6px;
      font-size: 11px;
      color: #bbb;
    }
    .sectionTitle {
      font-weight: 600;
      margin-top: 4px;
      margin-bottom: 2px;
      font-size: 12px;
    }
    .hint {
      margin-top: 4px;
      font-size: 11px;
      color: #888;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="title">MIDWAY</div>
    <div style="font-size: 11px; margin-bottom: 6px;">
      Shared swarm arena. Everyone at this URL sees the same universe.
    </div>
    <div id="controls">
      <button id="spawnFaction">Spawn New Faction</button>
      <button id="addChaos">Nudge Arena</button>
    </div>
    <div id="stats"></div>
    <div id="connectionStatus">Connecting…</div>
    <div class="hint">
      Open this page on two phones. When one spawns a faction or taps the arena,
      both see it. Tap anywhere to steer your own swarms.
    </div>
  </div>

  <canvas id="midway"></canvas>

  <script>
    const canvas = document.getElementById("midway");
    const ctx = canvas.getContext("2d");
    const statsDiv = document.getElementById("stats");
    const connectionStatus = document.getElementById("connectionStatus");

    const ARENA_WIDTH = 1280;
    const ARENA_HEIGHT = 720;

    function resize() {
      const scale = 0.8;
      canvas.width = window.innerWidth * scale;
      canvas.height = window.innerHeight * scale;
      canvas.style.width = "100vw";
      canvas.style.height = "100vh";
    }
    window.addEventListener("resize", resize);
    resize();

    function randomColorFromHue(hue) {
      return `hsl(${hue}, 80%, 60%)`;
    }

    const PLAYER_ID_KEY = "midwayPlayerId";
    let myPlayerId = localStorage.getItem(PLAYER_ID_KEY);
    if (!myPlayerId) {
      myPlayerId = "P" + Math.random().toString(36).slice(2, 8);
      localStorage.setItem(PLAYER_ID_KEY, myPlayerId);
    }

    let ws = null;
    let remoteState = null;

    function connectWebSocket() {
      const protocol = window.location.protocol === "https:" ? "wss" : "ws";
      const wsUrl = protocol + "://" + window.location.host;
      ws = new WebSocket(wsUrl);

      ws.addEventListener("open", () => {
        connectionStatus.textContent = "Connected to Midway server.";
      });

      ws.addEventListener("close", () => {
        connectionStatus.textContent = "Disconnected. Reconnecting…";
        setTimeout(connectWebSocket, 1500);
      });

      ws.addEventListener("error", () => {
        connectionStatus.textContent = "Connection error.";
      });

      ws.addEventListener("message", (event) => {
        let msg;
        try {
          msg = JSON.parse(event.data);
        } catch {
          return;
        }
        if (msg.type === "state") {
          remoteState = msg.state;
          updateStatsPanel();
        }
      });
    }

    connectWebSocket();

    document.getElementById("spawnFaction").addEventListener("click", () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({
        type: "spawnFaction",
        playerId: myPlayerId
      }));
    });

    document.getElementById("addChaos").addEventListener("click", () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type: "addChaos" }));
    });

    canvas.addEventListener("click", (event) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      if (!remoteState) return;

      const rect = canvas.getBoundingClientRect();
      const nx = (event.clientX - rect.left) / rect.width;
      const ny = (event.clientY - rect.top) / rect.height;

      const x = nx * ARENA_WIDTH;
      const y = ny * ARENA_HEIGHT;

      ws.send(JSON.stringify({
        type: "focusPoint",
        playerId: myPlayerId,
        x,
        y
      }));
    });

    function updateStatsPanel() {
      if (!remoteState) {
        statsDiv.innerHTML = "";
        return;
      }

      const factions = remoteState.factions || [];
      const agents = remoteState.agents || [];

      const counts = {};
      for (const a of agents) {
        counts[a.factionId] = (counts[a.factionId] || 0) + 1;
      }

      // Player scores
      const playerScores = {};
      for (const f of factions) {
        const owner = f.ownerId || "Arena";
        const c = counts[f.id] || 0;
        playerScores[owner] = (playerScores[owner] || 0) + c;
      }

      let html = "";

      html += `<div class="sectionTitle">Players</div>`;
      const entries = Object.entries(playerScores).sort((a, b) => b[1] - a[1]);
      for (const [owner, score] of entries) {
        const label = owner === myPlayerId ? "You" : owner;
        html += `<div>${label} – ${score} agents</div>`;
      }
      html += `<hr />`;

      html += `<div class="sectionTitle">Factions</div>`;
      for (const f of factions) {
        const c = counts[f.id] || 0;
        const owner = f.ownerId || "Arena";
        const ownerLabel = owner === myPlayerId ? "You" : owner;
        html += `<div>
          <span style="display:inline-block;width:9px;height:9px;border-radius:50%;background:${randomColorFromHue(f.colorHue)};margin-right:4px;"></span>
          ${f.id} – ${c} agents <span style="color:#888;">(${ownerLabel})</span>
        </div>`;
      }

      statsDiv.innerHTML = html;
    }

    function draw() {
      const width = canvas.width;
      const height = canvas.height;

      ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
      ctx.fillRect(0, 0, width, height);

      if (!remoteState || !remoteState.agents) {
        requestAnimationFrame(draw);
        return;
      }

      const factions = remoteState.factions || [];
      const agents = remoteState.agents || [];

      const factionColors = {};
      for (const f of factions) {
        factionColors[f.id] = randomColorFromHue(f.colorHue);
      }

      const sx = width / ARENA_WIDTH;
      const sy = height / ARENA_HEIGHT;
      const s = Math.min(sx, sy);

      const offsetX = (width - ARENA_WIDTH * s) / 2;
      const offsetY = (height - ARENA_HEIGHT * s) / 2;

      for (const a of agents) {
        const color = factionColors[a.factionId] || "#ffffff";
        const x = offsetX + a.x * s;
        const y = offsetY + a.y * s;
        const r = a.r * s;

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      requestAnimationFrame(draw);
    }

    requestAnimationFrame(draw);
  </script>
</body>
</html>
